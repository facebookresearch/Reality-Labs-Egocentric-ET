<?xml version="1.0" encoding="UTF-8" standalone="no" ?><!DOCTYPE function SYSTEM "qtfmfunction.dtd">function m = meani(q, tol)% MEANI  Computes the intrinsic mean of the elements of q. This is a unit% quaternion that minimises the sum of geodesic distances from m to unit% versions of the elements of q. The second (optional) parameter is an% angular tolerance on the result (in radians). Unlike the regular mean,% this function operates on all the quaternions in q as a set, rather than% by columns or along specific dimensions. This is because the intrinsic% mean must be computed on the whole set of values at once. (It is not% associative.)% Copyright © 2008 Stephen J. Sangwine, Nicolas Le Bihan and Salem Said.% See the file : Copyright.m for further details.% Reference:%% Samuel R. Buss and Jay P. Fillmore (2001), 'Spherical averages and% applications to spherical splines and interpolation', ACM Trans. Graph.,% 20(2), 95-126. DOI:10.1145/502122.502124.%% This paper describes two algorithms for computing the intrinsic mean (in% §3), and discusses the general principles (in §2), but the algorithm used% here is different. TODO Explain in what way!% TODO: Is it possible that this is the same thing as the spherical median,% defined by Fisher:%% N. I. Fisher, 'Spherical medians', J. Royal Statistical Society, Series% B, 47(2), 342-348, 1985.error(nargchk(1, 2, nargin)), error(nargoutchk(0, 1, nargout))if nargin == 1    tol = 0.1; % The tolerance was not specified, supply a default.endif nargin == 2 && (~isnumeric(tol) || ~isscalar(tol))    error('Second parameter must be a numeric scalar.')end% In the following statement, we need to use subscripted references, but% these do not work inside a class method (which this is). See the file% 'implementation notes.txt', item 8. The purpose of the following% statement is to make a vector, u, containing unit versions of all the% elements of q, regardless of the number of dimensions of q. This greatly% simplifies the remaining code, since we can handle quaternion arrays of% any size or shape or number of dimensions.u = unit(subsref(q, substruct('()', {1:prod(size(q))}))); % u = unit(q(1:end));% u is now a vector of unit quaternions with the same directions as% elements of q. We operate on u from here on, and not q, so the size and% number of dimensions of q is not relevant from here on.m = mean(u); % Initial value, somewhat arbitrary: take the Euclidean mean.if ~isreal(u)    warning('QTFM:information', ...        'The validity of MEANI on complexified quaternions is unknown.')endif abs(abs(m)) < eps % Use double abs in case m is complexified (note 1).    error('Intrinsic mean is indeterminate (geometric mean is zero).')endm = unit(m); % Now we can safely normalise the Euclidean mean, having             % checked that it is non-zero.while true    d = (m.^-1) .* u; % d is a vector of quaternions that will postmultiply                      % m to give u. Each element of d is a geodesic                      % distance measure since it rotates m to an element                      % of u. We are aiming to minimise this measure.    e = exp(mean(log(d))) % This is a correction factor that moves the                           % current estimate of the intrinsic mean nearer                           % the true value.    m = m .* e; % Update the estimate.    if (abs(angle(e)) <= tol), break; endend
<!--$Id$-->
