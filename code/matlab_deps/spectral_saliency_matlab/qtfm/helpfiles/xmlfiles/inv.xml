<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE function SYSTEM "qtfmfunction.dtd">
<function name = "inv" overload = "true">
<short>Inverse of quaternion matrix</short>
<syntax>Y = inv(X)</syntax>
<long>
<para>
Given a single quaternion, <code>inv(X)</code> computes the inverse, that
is the conjugate divided by the modulus. The inverse exists for all real
quaternions, but not for all complexified quaternions. An error will result
in cases where a complexified quaternion has no inverse.
</para>
<para>
Given a <italic>square</italic> quaternion matrix, <code>inv(X)</code>
computes a matrix inverse using an analytical formula based on partitioning
the matrix into sub-matrices. This formula is inevitably inaccurate for
larger matrices and a better method may be substituted in the future.
</para>
<para>
No warning is given if the matrix is singular - the result will be NaNs.
</para>
</long>
<examples>
<precode>
>> inv(qi + qj + qk)
 
ans = -0.3333 * I - 0.3333 * J - 0.3333 * K
 
>> ans * (qi + qj + qk)
 
ans = 1 + 0 * I + 0 * J + 0 * K
 
>> q = randq(3)
 
q = 3x3 quaternion array
 
>> show(q * inv(q))
 
S =
 
    1.0000    0.0000         0
    0.0000    1.0000   -0.0000
    0.0000   -0.0000    1.0000

X =
 
   1.0e-15 *

         0   -0.0139    0.0278
         0   -0.0833   -0.1665
   -0.0555    0.1249    0.1665

Y =
 
   1.0e-15 *

   -0.0278   -0.0555    0.0555
   -0.1665    0.0555    0.2220
    0.1110   -0.0555   -0.1110

Z =
 
   1.0e-15 *

         0   -0.0278    0.0035
    0.1110    0.0139    0.0555
    0.0555    0.0416         0
</precode>
</examples>
<seealso>
<matlabfun name = "inv"/>
</seealso>
<references>
<reference>R. A. Horn and C. R. Johnson, <italic>Matrix Analysis</italic>,
Cambridge University Press, 1985, §0.7.3, page 18.
</reference>
</references>
</function>

<!--$Id: inv.xml,v 1.3 2009/02/08 19:35:55 sangwine Exp $-->
